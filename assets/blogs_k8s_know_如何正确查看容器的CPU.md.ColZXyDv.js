import{_ as p,c as s,o as e,a2 as t}from"./chunks/framework.DukRYrIy.js";const a="/assets/image-20240417091640490.B2NU9K1J.png",c="/assets/image-20240417092217593.Bi_Lv-aE.png",o="/assets/image-20240417092446703.DmXSPcqw.png",i="/assets/image-20240417094031338.C1e2YzED.png",n="/assets/image-20240417095430995.tPb7sn1u.png",P=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/k8s/know/如何正确查看容器的CPU.md","filePath":"blogs/k8s/know/如何正确查看容器的CPU.md","lastUpdated":1713348792000}'),r={name:"blogs/k8s/know/如何正确查看容器的CPU.md"},_=t('<p>进入容器中top，虽然看到的PID是容器的，但是%Cpu的统计信息却是宿主机的。</p><p>如图</p><p><img src="'+a+'" alt="image-20240417091640490"></p><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h2><p>进程的cpu使用率是如何计算出来的？</p><p>每个进程的状态是放在文件里的，在/proc目录下，每个进程有自己pid命名的文件夹，</p><p><img src="'+c+'" alt="image-20240417092217593"></p><p>比如我现在这个jenkins的docker进程，通过inspect查询到Pid是30134</p><p><img src="'+o+'" alt="image-20240417092446703"></p><p>我们继续查看/proc/30134下的文件。</p><p>里面的文件比较多，我们现在只关心stat文件</p><blockquote><p>[root@paas-m-k8s-node-1 30134]# cat stat 30134 (tini) S 30112 30134 30134 0 -1 1077944576 1639 0 0 0 244 934 0 0 20 0 1 0 2352840503 2514944 114 18446744073709551615 94288423874560 94288423890205 140731692225440 140731692224320 139648449412143 0 0 3145728 0 18446744072548467014 0 0 17 12 0 0 0 0 0 94288423901968 94288423904395 94288443621376 140731692228014 140731692228057 140731692228057 140731692228586 0</p></blockquote><p>这个stat文件是进程的实时状态信息，实时输出了进程的状态信息，比如进程的运行态（Running 还是</p><p>Sleeping）、父进程 PID、进程优先级、进程使用的内存等等总共 50 多项。</p><p>这些指标每个空格隔开是一项，现在就看第14项时utime，即进程的用户态部分占用的cpu时间片。244</p><p>第15项是 stime，即进程的内核态部分占用的cpu时间片。934</p><p>需要注意的是，utime 和 stime 都是一个累计值，也就是说从进程启动开始，这两个值就是一直在累积增长的</p><p>然后根据这两个值来计算进程的cpu使用率。具体的计算公式就不讲了。</p><p>上面是单个进程的cpu使用计算，那整个系统的cpu数据在哪？</p><p>在/proc/stat文件</p><p><img src="'+i+'" alt="image-20240417094031338"></p><p>明白了</p><p>在容器里top看到的是宿主机的cpu的原因就是，top查的是/proc/stat文件，这个文件是反应整个宿主机的状态信息的，不是单个容器的。</p><p>有什么办法吗</p><p>我们知道每个容器有自己的cpu cgroup控制组，在这个控制组的目录下有很多文件</p><p>比如我现在的容器cgroup的目录是</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>/sys/fs/cgroup/cpuacct/system.slice/docker-1a97854ff7856b7327122bea18c3676f05cd2bf74e9502fe24370c8f011ceb1c.scope</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>其中有个cpuacct.stat文件，就有整个容器的cpu信息</p><p>注意，这里的user和system的信息也是累计值</p><p>所以我们可以每秒获取一次，通过计算得到实时的cpu使用率。</p><p><img src="'+n+'" alt="image-20240417095430995"></p><p>很多工具如Prometheus，k8s中的资源计算，docker的计算最终都是从这个cgroup文件来的。</p><p>单台节点上容器数量小于1000，计算周期位10s的情况下，计算资源的消耗很小。</p><p>是不是还是感觉很麻烦，下一篇分享一个小工具帮我们解决这个问题。</p>',34),m=[_];function l(u,d,g,b,h,k){return e(),s("div",null,m)}const v=p(r,[["render",l]]);export{P as __pageData,v as default};
