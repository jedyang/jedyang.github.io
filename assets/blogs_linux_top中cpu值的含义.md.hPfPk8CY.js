import{_ as p,c as a,o as e,a2 as s}from"./chunks/framework.DukRYrIy.js";const t="/assets/a67fae56ce2f4e7078d552c58c9f9dc2.CG7Ww5LS.webp",c="/assets/7dbd023628f5f4165abc23c1d67aca99.D9nIdns5.webp",i="/assets/a4f537187a16e872ebcc605d972672a3.CqDIgFx2.jpeg",h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/linux/top中cpu值的含义.md","filePath":"blogs/linux/top中cpu值的含义.md","lastUpdated":1713348792000}'),o={name:"blogs/linux/top中cpu值的含义.md"},_=s('<p>我们在使用top命令时，会看到如下参数。在cpu那一行看到us，sy等多个指标。</p><p>这些指标你真的全都了解吗？</p><p>在网上看到一个解释的非常清晰的图，保证你绝对能清晰的明白这些指标的含义</p><p><img src="'+t+'" alt="a67fae56ce2f4e7078d552c58c9f9dc2"></p><p>神图在此</p><p><img src="'+c+'" alt="7dbd023628f5f4165abc23c1d67aca99"></p><h2 id="解释" tabindex="-1">解释 <a class="header-anchor" href="#解释" aria-label="Permalink to &quot;解释&quot;">​</a></h2><p>我们知道linux运行状态分为用户态和内核态。</p><p>横线的上半部分时用户态。下半部分是内核态。</p><p>当一个用户程序开始执行，它首先处于用户态，用CPU使用率中的“us”（user的缩写）来表示。在这个状态下，除了系统调用之外的所有代码执行都会计算在“us”的CPU使用时间内。</p><p>一旦用户程序执行系统调用，如read()函数来读取文件，它就会从用户态切换到内核态。在内核态中，read()系统调用会首先在文件系统层面进行操作，这一阶段的CPU使用时间会计入“sy”（即system的缩写）。</p><p>随后，read()系统调用会向Linux的块设备层发起I/O请求，开始实际的磁盘读取操作。在这个过程中，进程通常会变为不可中断状态，而这段时间会被标记为“wa”（即wait的缩写）。</p><p>数据从磁盘读取并返回后，进程在内核态接收这些数据，这仍然属于“sy”的CPU使用时间。之后，进程会从内核态切换回用户态，并在用户态中处理文件数据。这又计算到us的时间内了。</p><p>如果在此之后，假设用户进程没有其他任务需要执行就进入休眠状态，同时CPU上也没有其他进程需要运行，那么系统就会进入空闲状态，表示为“id”（idle的缩写）。</p><p>当系统接收到一个网络数据包时，网卡会触发一个中断，CPU会响应这个中断并执行中断服务程序。这时，CPU的使用时间会计入“hi”（hardware irq硬件中断的意思）。</p><p>对于中断处理过程中耗时较长的任务，Linux提供了软中断（si）机制来处理。</p><p>不管是硬中断hi还是软中断si，它们的CPU使用时间都不会计入进程的CPU时间，因为处理这些中断的时间不属于任何特定进程。</p><p>此外，还有两种CPU使用时间类型：“nice”（ni）和“steal”（st）。nice值正数表示低优先级进程占用的CPU时间，而steal是在虚拟化环境中使用的，表示被同一宿主机上的其他虚拟机偷走的CPU时间。steal这个词用的很形象啊。</p><p>最后总结一下</p><p><img src="'+i+'" alt="img"></p>',20),r=[_];function d(n,l,u,f,m,P){return e(),a("div",null,r)}const U=p(o,[["render",d]]);export{h as __pageData,U as default};
