import{_ as a,c as s,o as e,a2 as n}from"./chunks/framework.DukRYrIy.js";const p="/assets/image-20240417104958385.DWLUxaTR.png",t="/assets/image-20240417135005113.D2HjTJGo.png",k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/k8s/know/topic.md","filePath":"blogs/k8s/know/topic.md","lastUpdated":1713348792000}'),i={name:"blogs/k8s/know/topic.md"},c=n(`<p>上一篇，我们明白了为啥容器内top查看的是宿主机的资源消耗。</p><p>这里分享一个工具，在容器里代替top命令用于查看容器自身的资源消耗</p><h2 id="topic" tabindex="-1">topic <a class="header-anchor" href="#topic" aria-label="Permalink to &quot;topic&quot;">​</a></h2><p>topic 即 top in container的缩写，意味容器内的top命令</p><p>针对容器内查看系统状态的问题，目前比较通用的解决方案是通过lxcfs，将容器中相应的文件通过fuse劫持read调用，在打开时显示为容器信息，从而统一解决各种系统状态诊断工具的问题。</p><p>考虑到部署lxcfs有一定的成本，topic(top in container)的思路则是改造top命令，去适配容器，读取容器中反映真实运行情况的系统文件，从而展示正确的容器运行信息，对于用户而言成本更低。</p><h2 id="安装使用" tabindex="-1">安装使用 <a class="header-anchor" href="#安装使用" aria-label="Permalink to &quot;安装使用&quot;">​</a></h2><p>下载地址：<a href="https://github.com/silenceshell/topic" target="_blank" rel="noreferrer">silenceshell/topic: top in container. (github.com)</a></p><h3 id="make" tabindex="-1">make <a class="header-anchor" href="#make" aria-label="Permalink to &quot;make&quot;">​</a></h3><p>下载的是源码，需要自己make一下，发出二进制包</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>wget https://github.com/silenceshell/topic/archive/refs/tags/0.0.4.tar.gz</span></span>
<span class="line"><span>mkdir topic &amp;&amp; tar -zxvf 0.0.4.tar.gz -C topic</span></span>
<span class="line"><span>cd topic/topic-0.0.4/ &amp;&amp; make build</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="复制到需要的容器" tabindex="-1">复制到需要的容器 <a class="header-anchor" href="#复制到需要的容器" aria-label="Permalink to &quot;复制到需要的容器&quot;">​</a></h3><p>假设我有一个创建一个2c2g限制的业务容器，比如tomcat</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker run -d --name topic-test --cpus 2 --memory 2g tomcat:9.0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="`+p+`" alt="image-20240417104958385"></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker cp topic topic-test:/usr/bin</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>加一下可执行权限</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker exec -it topic-test sh</span></span>
<span class="line"><span>chmod +x topic</span></span>
<span class="line"><span>topic</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>现在的cpu和内存都是容器自己的</p><p><img src="`+t+'" alt="image-20240417135005113"></p>',20),o=[c];function l(r,d,h,m,u,b){return e(),s("div",null,o)}const v=a(i,[["render",l]]);export{k as __pageData,v as default};
